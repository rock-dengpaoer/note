软件安装
############################

程序简介
*********************

linux系统上真正识别的可执行文件其实是二进制程序。

file命令，如果是二进制而且是可以执行的时候，就会显示执行文件类别（ELF 64-bit LSB），
同时会说明是否使用**动态函数库**（shared libs），如果是一般的脚本，就会显示出
text executables之类的字样。

纯文本文件类型的程序源代码通过编译器编译成为操作系统看得懂的二进制程序。
有的时候，会在程序当中【引用，调用】其他的外部子程序，或是利用其他软件提供的
【函数功能】，这个时候，就必须在编译的过程中，将该函数库加进去，编译器就可以将
所有的程序代码与函数库作一个链接（link）以产生正常的执行文件。

- 开放源代码：就是程序代码，写给人类看的程序语言，但机器并不认识，所以无法执行。
- 编译器：将程序代码转译成为机器看得懂的语言，就类似翻译者的角色。
- 可执行文件：经过编译器编译生成的二进制程序，机器看得懂，所以可以执行。

函数库
*****************

函数库又分为动态和静态的函数库。

如果要在程序里边加入引用的函数库，即在编译的过程中，加入函数库的相关设置。

事实上，linux内核提供了很多与内核相关的函数库与外部参数，这些内核功能在设计硬件
的驱动程序的时候是相当有用的信息。

- 函数库：就类似子程序的角色，是可以被调用来执行的一段功能函数。
  
make
**************************

make可以使编译过程简化

当执行make是，make会在当前的目录下查找Markfile（or makefile）这个文本文件，而
Markfile里边则记录了源代码如何编译的详细信息。

make会自动地判断源代码是否经过变动了，而自动更新执行文件，是软件工程师相当好用的一个
辅助工具。

Markfile如何写

.. note:: 通常软件开发商都会写一个检测程序来检测用户的操作环境，以及该操作环境是否有软件开发商所需要的其他功能，该检测程序检测完毕后，就会主动地建立这个Markfile的规则文件，通常这个检测程序的文件名为configure或是config

为什么要检测操作环境？ 不同版本的内核所使用的系统调用可能不相同，而且每个软件所需要依赖
的函数库也不相同，同时软件开发山不会仅针对linux开发，而是会针对整个UNIX-like做开发，
所以它也必须要检测该操作系统平台有没有提供合适的编辑器才行。

一般来说，检测程序会检测的内容为：

- 是否有合适的编译器可以编译本软件的程序代码。
- 是否已经存在本软件所需要的函数库，或其他需要的依赖软件。
- 操作系统平台是否适合本软件，包括linux的内核版本。
- 内核的头文件（header include）是否存在（驱动层序必须要检测）。

同一个软件要在不同的平台上边执行时，必须要重新编译，所以才需要源代码。

Tarball软件
*************************

所谓的Tarball文件，其实就是将软件的所有源代码文件先以tar打包，然后再以压缩技术来压缩,
通常最常见的就是以gzip来压缩。因为利用了tar与gzip的功能，所以Tarball文件一般的扩展名
就会写成*.tar.gz或者简写为*.tgz。   
现在渐渐以bzip2及xz的压缩技术来替换gzip,因此文件也会编程*.tar.bz2、*.tar.xz之类

Tarball就是一个软件包，里边的文件通常有:

- 源代码文件
- 检测程序文件（可能是configure或是config等文件）
- 本软件的简易说明与安装说明（INSTALL或是README）


如何安装与升级软件
***************************

升级的原因

- 需要新的功能，但旧有主机的旧版软件并没有，所以需要升级到新版的软件。
- 旧版本的软件上面可能有信息安全上的缺陷，所以需要更新到新版的软件。
- 旧版的软件执行性能不佳，或是功能不能让管理者满足。

升级的方式

- 直接以源代码通过编译来安装与升级。
- 直接以编译好的二进制程序来安装和升级。


一个软件的Tarball安装流程：

1. 将Tarball由厂商的网站下载；
2. 将Tarball解开，产生很多的源代码文件；
3. 开始以gcc进行源代码的编译（会产生目标文件object files）；
4. 然后以gcc进行函数库、主、子程序的链接，以形成主要的二进制文件；
5. 将上述的二进制文件以及相关的配置文件安装至自己的主机上边。

.. tip:: 3、4步骤可以通过make命令来简化

在默认的状态下，如果我们直接以gcc编译源代码，并且没有加上任何参数，则执行文件的文件名会被自动设置为a.out。
a.out就是编译成功的可执行二进制程序。

如果在一个主程序里边又调用了另一个主程序，编译流程为：

.. code-block:: c

   vim thanks.c
   #include <stdio.h>
   int main()
   {
      printf("Hello World\n");
      thanks2();
   }

   vim thanks_2.c
   #include <stdio.h>
   void thanks2()
   {
      printf("thank you!\n");
   }

进行程序的编译与链接（link）

.. code-block:: c

   gcc -c thanks.c thanks_2.c
   gcc -o thanks thanks.o thanks_2.o

由于我们的源代码文件有时并非仅只有一个文件，所以我们无法直接进行编译，这个时候就需要先产生
目标文件，然后再以链接制作成为二进制可执行文件。

**另外，如果有一天，你更新了thanks_2.c这个文件的内容，则你只要重新编译thanks_2.c来产生
新的thanks_2.o，然后再以链接制作出新的二进制可执行文件即可，而不必重新编译其他没有修改
过的源代码文件。**

调用外部函数库：加入链接的函数库

.. 
   gcc sin.c -lm -L/lib -L/lib64

- -l 是加入某个函数库（library）的意思
- -m 则是lim.so这个函数库，其中，lib与扩展名（.a或.so）不需要写

-lm表示使用libm.so（或libm.a）这个函数库的意思，-L后边的路径表示，函数库libm.so在/lib或/lib64里边寻找。

用make进行宏编译
**********************

make的功能是可以简化编译过程里边所执行的命令，同时还具有很多很方便的功能。

make的好处

- 简化编译时所需执行的命令
- 若在编译完成之后，修改了某个源代码文件，则make仅会针对被修改了的文件进行编译，其他的目标文件不会被修改。
- 最后可以依照依赖性来更新（update）执行文件。

makefile的基本语法与变量

.. 
   目标（target）： 目标文件1 目标文件2
   <tab> gcc -o 欲建立的可执行文件 目标文件1 目标文件2

目标（target）就是我们想要建立的信息，目标文件就是所有具有相关性的目标文件，
**命令行必须要以Tab键作为开头**，规则为：

- 在makefile 当中的#代表注释；
- <tab>需要再命令行（例如gcc这个编译器命令）的第一个字符；
- 目标（target）与依赖文件（就是目标文件）之间需以【:】隔开；

Tarball安装的基本步骤
****************************
1. ./configure::

    建立Makefile文件。通常程序开发者会写一个脚本来检查你的linux系统、相关的软件属性等。

2. make clean::

    make会读取Makefile中关于clean的工作，这个步骤不一定会有，但是希望执行一下，因为可以移除目标文件。

3. make::

    make会根据Makefile当中的默认设置进行编译的操作。

4. make install::

    make会根据Makefile这个文件里边关于install的选项，将上一个步骤所编译完成的内容安装到预定的目录中，从而完成安装。

其中只要一个步骤无法成功，那么后续的步骤就完全没有办法进行。

